<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DSA Flashcards by Claude And Aswin.</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font:14px/1.6 'Segoe UI',monospace;background:#f5f5dc;color:#333;padding:20px}
.filter{display:flex;gap:8px;margin-bottom:15px;flex-wrap:wrap;align-items:center}
.filter button{padding:6px 12px;border:1px solid #999;background:#fff;cursor:pointer;border-radius:3px;transition:all .2s}
.filter button:hover{background:#f0f0f0}
.filter button.active{background:#dda0dd;color:#fff;border-color:#dda0dd}
.filter label{font-weight:bold;color:#8b4513;margin-right:5px}
.card{background:#fff;border:1px solid #ccc;padding:18px;margin-bottom:15px;border-radius:6px;box-shadow:0 2px 4px rgba(0,0,0,.05)}
.card.hidden{display:none}
.unit{font-size:11px;color:#888;margin-bottom:8px;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.topic{font-size:10px;color:#999;margin-bottom:8px;font-style:italic}
.q{font-weight:600;margin-bottom:12px;color:#2c3e50;font-size:15px}
.a{margin-top:12px;padding:14px;background:#f9f9f9;border-left:4px solid #dda0dd;display:none;line-height:1.8;border-radius:3px}
.a.show{display:block}
.a strong{color:#8b4513}
.a br{display:block;content:"";margin:4px 0}
.cloze{background:#ffeb3b;padding:3px 6px;border-radius:2px;font-weight:600}
.cloze.revealed{background:transparent;color:#27ae60}
.btns{margin-top:12px;display:flex;gap:8px}
button{padding:6px 12px;border:1px solid #999;background:#fff;cursor:pointer;font-size:12px;border-radius:3px;transition:all .2s}
button:hover{background:#e8e8e8;border-color:#666}
h1{font-size:22px;margin-bottom:20px;color:#8b4513;font-weight:700}
.filters-container{background:#fff;padding:15px;border-radius:6px;margin-bottom:20px;border:1px solid #ddd}
</style>
</head>
<body>
<h1>ðŸ“š Data Structures Flashcards</h1>
<div class="filters-container">
<div class="filter" id="unitFilter"></div>
<div class="filter" id="topicFilter" style="margin-top:10px"></div>
</div>
<div id="cards"></div>

<script>
const data=[
{u:"II",topic:"Stack",q:"What is a Stack?",a:"<strong>LIFO</strong> (Last In First Out) linear data structure<br><br>â€¢ Operations at one end (TOP)"},
{u:"II",topic:"Stack",q:"Basic Stack operations?",a:"â€¢ <strong>PUSH</strong>: insert at top<br><br>â€¢ <strong>POP</strong>: remove from top<br><br>â€¢ <strong>PEEK/TOP</strong>: view top<br><br>â€¢ isEmpty, isFull"},
{u:"II",topic:"Stack",q:"PUSH algorithm steps?",a:"1. Check overflow (TOP=MAX-1)<br><br>2. TOP++<br><br>3. STACK[TOP]=ITEM"},
{u:"II",topic:"Stack",q:"POP algorithm steps?",a:"1. Check underflow (TOP=-1)<br><br>2. ITEM=STACK[TOP]<br><br>3. TOP--"},
{u:"II",topic:"Stack",q:"Array implementation limitation?",a:"â€¢ Fixed size<br><br>â€¢ <strong>Overflow</strong> if TOP=MAX-1<br><br>â€¢ <strong>Underflow</strong> if TOP=-1"},
{u:"II",topic:"Stack",q:"Linked list stack advantage?",a:"â€¢ Dynamic size, no overflow<br><br>â€¢ TOP = head pointer<br><br>â€¢ PUSH at head, POP from head"},
{u:"II",topic:"Stack",q:"How stack supports recursion?",a:"Stores <strong>activation records</strong> for each function call:<br><br>â€¢ Local variables<br><br>â€¢ Return address<br><br>â€¢ Parameters"},
{u:"II",topic:"Stack",q:"Convert A+B*C to postfix?",a:"<strong>ABC*+</strong><br><br>â€¢ Operators after operands<br><br>â€¢ Higher precedence first"},
{u:"II",topic:"Stack",q:"Evaluate postfix expression?",a:"â€¢ Scan left to right<br><br>â€¢ Push operands<br><br>â€¢ Pop 2 for operator<br><br>â€¢ Push result"},
{u:"II",topic:"Stack",q:"Stack applications?",a:"â€¢ Recursion<br><br>â€¢ Expression conversion<br><br>â€¢ Parentheses matching<br><br>â€¢ Backtracking<br><br>â€¢ Undo/redo<br><br>â€¢ Browser history"},
{u:"II",topic:"Stack",q:"When does stack overflow occur?",a:"When PUSH attempted and <strong>TOP = MAX-1</strong><br><br>(array is full)"},
{u:"II",topic:"Stack",q:"When does stack underflow occur?",a:"When POP attempted and <strong>TOP = -1</strong><br><br>(stack is empty)"},
{u:"II",topic:"Stack",q:"Check balanced parentheses?",a:"1. Push '(' to stack<br><br>2. Pop for ')'<br><br>3. Empty stack at end = balanced"},
{u:"II",topic:"Stack",q:"Tower of Hanoi uses?",a:"<strong>Recursion/Stack</strong><br><br>To move n disks:<br><br>â€¢ Move n-1 to auxiliary<br><br>â€¢ Move nth to destination<br><br>â€¢ Move n-1 to destination"},
{u:"II",topic:"Queue",q:"What is a Queue?",a:"<strong>FIFO</strong> (First In First Out) linear structure<br><br>â€¢ Insert at REAR<br><br>â€¢ Delete from FRONT"},
{u:"II",topic:"Queue",q:"Basic Queue operations?",a:"â€¢ <strong>ENQUEUE</strong>: insert at rear<br><br>â€¢ <strong>DEQUEUE</strong>: delete from front<br><br>â€¢ <strong>PEEK</strong>: view front<br><br>â€¢ isEmpty, isFull"},
{u:"II",topic:"Queue",q:"ENQUEUE algorithm?",a:"1. Check overflow (REAR=MAX-1)<br><br>2. REAR++<br><br>3. Q[REAR]=ITEM"},
{u:"II",topic:"Queue",q:"DEQUEUE algorithm?",a:"1. Check underflow (FRONT>REAR)<br><br>2. ITEM=Q[FRONT]<br><br>3. FRONT++"},
{u:"II",topic:"Queue",q:"Circular queue advantage?",a:"â€¢ Reuses empty spaces<br><br>â€¢ REAR = (REAR+1) % MAX<br><br>â€¢ Full when (REAR+1)%MAX = FRONT"},
{u:"II",topic:"Queue",q:"What is Deque?",a:"<strong>Double-ended queue</strong><br><br>â€¢ Insert at both ends<br><br>â€¢ Delete from both ends"},
{u:"II",topic:"Queue",q:"Input Restricted Deque?",a:"â€¢ Insert at one end (REAR)<br><br>â€¢ Delete at both ends"},
{u:"II",topic:"Queue",q:"Output Restricted Deque?",a:"â€¢ Insert at both ends<br><br>â€¢ Delete from one end (FRONT)"},
{u:"II",topic:"Queue",q:"Queue applications?",a:"â€¢ CPU scheduling<br><br>â€¢ Printer spooling<br><br>â€¢ BFS traversal<br><br>â€¢ Buffers<br><br>â€¢ Customer service"},
{u:"II",topic:"Queue",q:"Priority Queue?",a:"Element with <strong>highest priority</strong> dequeued first<br><br>â€¢ Implemented using heap"},
{u:"II",topic:"Queue",q:"Problem with linear queue array?",a:"<strong>Wasted space</strong><br><br>â€¢ Even if queue empty, can't insert if REAR=MAX-1"},
{u:"II",topic:"Queue",q:"Queue using linked list?",a:"â€¢ <strong>FRONT</strong> points to first node<br><br>â€¢ <strong>REAR</strong> points to last node<br><br>â€¢ ENQUEUE at REAR<br><br>â€¢ DEQUEUE from FRONT"},
{u:"III",topic:"Trees - Basic",q:"What is a Tree?",a:"<strong>Non-linear hierarchical</strong> structure<br><br>â€¢ Root node<br><br>â€¢ Parent-child relationships<br><br>â€¢ No cycles"},
{u:"III",topic:"Trees - Basic",q:"Key tree terms?",a:"â€¢ Root, leaf, parent, child<br><br>â€¢ Sibling, ancestor, descendant<br><br>â€¢ Degree, height, depth, level"},
{u:"III",topic:"Trees - Binary",q:"Binary Tree definition?",a:"Each node has <strong>max 2 children</strong> (left, right)<br><br>â€¢ Max nodes at level i = 2^i"},
{u:"III",topic:"Trees - Binary",q:"Complete Binary Tree?",a:"â€¢ All levels filled except last<br><br>â€¢ Last level filled <strong>left to right</strong>"},
{u:"III",topic:"Trees - Binary",q:"Full Binary Tree?",a:"Every node has <strong>0 or 2 children</strong><br><br>â€¢ No node with 1 child"},
{u:"III",topic:"Trees - Binary",q:"Skewed Binary Tree?",a:"â€¢ <strong>Left-skewed</strong>: only left children<br><br>â€¢ <strong>Right-skewed</strong>: only right children"},
{u:"III",topic:"Trees - Binary",q:"Expression Tree?",a:"â€¢ Operators at <strong>internal nodes</strong><br><br>â€¢ Operands at <strong>leaves</strong><br><br>â€¢ Used for expression evaluation"},
{u:"III",topic:"Trees - Binary",q:"Binary tree properties?",a:"â€¢ Max nodes = 2^(h+1) - 1<br><br>â€¢ Min height = logâ‚‚(n+1)<br><br>â€¢ Leaf nodes = Internal nodes with 2 children + 1"},
{u:"III",topic:"Trees - Binary",q:"Degree of a node?",a:"Number of children<br><br>â€¢ Max degree of binary tree = <strong>2</strong>"},
{u:"III",topic:"Trees - Binary",q:"Height of tree?",a:"Max distance from root to leaf<br><br>â€¢ Height of root = 0 or 1 (convention varies)"},
{u:"III",topic:"Trees - Binary",q:"Count leaves in binary tree?",a:"If internal nodes with 2 children = i<br><br>Then leaves = <strong>i + 1</strong>"},
{u:"III",topic:"Trees - Binary",q:"Strict binary tree?",a:"Same as <strong>full binary tree</strong><br><br>â€¢ Every node has 0 or 2 children"},
{u:"III",topic:"Trees - Binary",q:"Perfect binary tree?",a:"â€¢ All internal nodes have 2 children<br><br>â€¢ AND all leaves at <strong>same level</strong>"},
{u:"III",topic:"Trees - Representation",q:"Array representation formula?",a:"<strong>Parent at i:</strong><br><br>â€¢ Left child: 2i+1<br><br>â€¢ Right child: 2i+2<br><br><strong>Child at i:</strong><br><br>â€¢ Parent: (i-1)/2"},
{u:"III",topic:"Trees - Representation",q:"Linked representation?",a:"<strong>Node structure:</strong><br><br>â€¢ Data<br><br>â€¢ Left pointer<br><br>â€¢ Right pointer<br><br>â€¢ Root pointer points to root"},
{u:"III",topic:"Trees - Traversal",q:"Inorder traversal?",a:"<strong>Left-Root-Right</strong><br><br>â€¢ Gives sorted sequence for BST<br><br>â€¢ Recursive: traverse left â†’ visit â†’ traverse right"},
{u:"III",topic:"Trees - Traversal",q:"Preorder traversal?",a:"<strong>Root-Left-Right</strong><br><br>â€¢ Used for copying tree<br><br>â€¢ Polish notation"},
{u:"III",topic:"Trees - Traversal",q:"Postorder traversal?",a:"<strong>Left-Right-Root</strong><br><br>â€¢ Used for deleting tree<br><br>â€¢ Reverse Polish notation"},
{u:"III",topic:"Trees - Traversal",q:"Level order traversal?",a:"Visit nodes <strong>level by level</strong> (BFS)<br><br>â€¢ Use queue"},
{u:"III",topic:"Trees - Traversal",q:"Non-recursive traversal?",a:"Use <strong>stack</strong><br><br>For inorder:<br><br>â€¢ Go left pushing nodes<br><br>â€¢ Pop and visit<br><br>â€¢ Go right"},
{u:"III",topic:"Trees - BST",q:"Binary Search Tree?",a:"<strong>Left subtree &lt; Root &lt; Right subtree</strong><br><br>â€¢ Enables binary search<br><br>â€¢ Time: O(log n) average"},
{u:"III",topic:"Trees - BST",q:"BST insertion?",a:"1. Start at root<br><br>2. Go left if smaller, right if larger<br><br>3. Insert at NULL position"},
{u:"III",topic:"Trees - BST",q:"BST deletion cases?",a:"<strong>Case 1 - Leaf:</strong> remove directly<br><br><strong>Case 2 - One child:</strong> replace with child<br><br><strong>Case 3 - Two children:</strong> replace with inorder successor/predecessor"},
{u:"III",topic:"Trees - BST",q:"BST search algorithm?",a:"1. Start at root<br><br>2. If key &lt; node, go left<br><br>3. If key &gt; node, go right<br><br>4. If NULL, not found<br><br>â€¢ Time: O(h)"},
{u:"III",topic:"Trees - BST",q:"Find min/max in BST?",a:"â€¢ <strong>Min:</strong> leftmost node<br><br>â€¢ <strong>Max:</strong> rightmost node"},
{u:"III",topic:"Trees - BST",q:"Inorder successor in BST?",a:"<strong>If right child exists:</strong><br><br>â€¢ Min of right subtree<br><br><strong>Else:</strong><br><br>â€¢ Nearest ancestor for which node is in left subtree"},
{u:"III",topic:"Trees - AVL",q:"AVL Tree?",a:"<strong>Self-balancing BST</strong><br><br>â€¢ Height difference of subtrees â‰¤ 1<br><br>â€¢ Operations: O(log n)"},
{u:"III",topic:"Trees - AVL",q:"Balance factor in AVL?",a:"BF = height(left) - height(right)<br><br>â€¢ Must be <strong>-1, 0, or 1</strong>"},
{u:"III",topic:"Trees - AVL",q:"AVL rotation types?",a:"â€¢ <strong>LL</strong>: right rotation<br><br>â€¢ <strong>RR</strong>: left rotation<br><br>â€¢ <strong>LR</strong>: left-right rotation<br><br>â€¢ <strong>RL</strong>: right-left rotation"},
{u:"III",topic:"Trees - Applications",q:"Tree applications?",a:"â€¢ File system<br><br>â€¢ DOM (HTML/XML)<br><br>â€¢ Expression parsing<br><br>â€¢ BST for searching<br><br>â€¢ Decision trees<br><br>â€¢ Heap"},
{u:"III",topic:"Graph - Basic",q:"What is a Graph?",a:"<strong>G = (V, E)</strong><br><br>â€¢ V: Set of vertices<br><br>â€¢ E: Set of edges<br><br>â€¢ Non-linear structure"},
{u:"III",topic:"Graph - Basic",q:"Graph terms?",a:"â€¢ Vertex, edge, adjacent<br><br>â€¢ Degree, path, cycle<br><br>â€¢ Connected, complete graph"},
{u:"III",topic:"Graph - Types",q:"Directed Graph?",a:"Edges have <strong>direction</strong> (arrows)<br><br>â€¢ In-degree<br><br>â€¢ Out-degree"},
{u:"III",topic:"Graph - Types",q:"Undirected Graph?",a:"Edges <strong>bidirectional</strong><br><br>â€¢ Degree = number of edges"},
{u:"III",topic:"Graph - Types",q:"Weighted Graph?",a:"Edges have <strong>weights/costs</strong><br><br>â€¢ Used for shortest path algorithms"},
{u:"III",topic:"Graph - Types",q:"Complete Graph edges?",a:"Every vertex connected to every other<br><br>â€¢ Edges = <strong>n(n-1)/2</strong> for undirected"},
{u:"III",topic:"Graph - Types",q:"Path in graph?",a:"Sequence of vertices where each adjacent pair connected by edge"},
{u:"III",topic:"Graph - Types",q:"Cycle in graph?",a:"Path that starts and ends at <strong>same vertex</strong><br><br>â€¢ No repeated edges"},
{u:"III",topic:"Graph - Types",q:"Connected graph?",a:"Path exists between <strong>every pair</strong> of vertices<br><br>â€¢ For directed: strongly connected"},
{u:"III",topic:"Graph - Types",q:"Spanning tree?",a:"Subgraph containing:<br><br>â€¢ All vertices<br><br>â€¢ Min edges (<strong>V-1</strong>)<br><br>â€¢ Forms tree (no cycles)"},
{u:"III",topic:"Graph - Representation",q:"Adjacency Matrix?",a:"2D array: A[i][j] = 1 if edge exists<br><br>â€¢ Space: <strong>O(VÂ²)</strong><br><br>â€¢ Good for dense graphs"},
{u:"III",topic:"Graph - Representation",q:"Adjacency List?",a:"Array of linked lists<br><br>â€¢ List[i] = neighbors of vertex i<br><br>â€¢ Space: <strong>O(V+E)</strong>"},
{u:"III",topic:"Graph - Traversal",q:"Depth First Search?",a:"Go <strong>deep</strong> using stack/recursion<br><br>â€¢ Mark visited<br><br>â€¢ Time: O(V+E)"},
{u:"III",topic:"Graph - Traversal",q:"Breadth First Search?",a:"<strong>Level-wise</strong> using queue<br><br>â€¢ Mark visited<br><br>â€¢ Shortest path in unweighted<br><br>â€¢ Time: O(V+E)"},
{u:"III",topic:"Graph - Traversal",q:"DFS implementation?",a:"1. Push start, mark visited<br><br>2. Pop, process node<br><br>3. Push unvisited neighbors<br><br>â€¢ Use stack"},
{u:"III",topic:"Graph - Traversal",q:"BFS implementation?",a:"1. Enqueue start, mark visited<br><br>2. Dequeue, process node<br><br>3. Enqueue unvisited neighbors<br><br>â€¢ Use queue"},
{u:"III",topic:"Graph - Traversal",q:"Degree sum theorem?",a:"Sum of degrees of all vertices = <strong>2 Ã— number of edges</strong>"},
{u:"III",topic:"Graph - Applications",q:"Graph applications?",a:"â€¢ Social networks<br><br>â€¢ Maps/GPS navigation<br><br>â€¢ Web crawling<br><br>â€¢ Network routing<br><br>â€¢ Dependency resolution"},
{u:"IV",topic:"Sorting - Basics",q:"What is Sorting?",a:"Arranging elements in a specific order<br><br>â€¢ <strong>Ascending</strong> or <strong>Descending</strong><br><br>â€¢ Makes data easier to search and analyze"},
{u:"IV",topic:"Sorting - Basics",q:"Internal vs External Sorting?",a:"<strong>Internal:</strong> All data fits in memory<br><br>â€¢ Fast, uses RAM<br><br><strong>External:</strong> Data stored externally (disk)<br><br>â€¢ Used for large datasets"},
{u:"IV",topic:"Sorting - Selection",q:"Selection Sort algorithm?",a:"1. Find minimum element from unsorted part<br><br>2. Swap with first unsorted position<br><br>3. Move boundary forward<br><br>â€¢ Time: O(nÂ²)"},
{u:"IV",topic:"Sorting - Selection",q:"Selection Sort characteristics?",a:"â€¢ <strong>Unstable</strong> sorting<br><br>â€¢ Fewer swaps than bubble sort<br><br>â€¢ Time: O(nÂ²) all cases<br><br>â€¢ Space: O(1)"},
{u:"IV",topic:"Sorting - Bubble",q:"Bubble Sort algorithm?",a:"1. Compare adjacent elements<br><br>2. Swap if in wrong order<br><br>3. Repeat until no swaps needed<br><br>â€¢ Larger elements 'bubble up'"},
{u:"IV",topic:"Sorting - Bubble",q:"Bubble Sort characteristics?",a:"â€¢ Simple but inefficient<br><br>â€¢ <strong>Stable</strong> sorting<br><br>â€¢ Best: O(n), Worst: O(nÂ²)<br><br>â€¢ Good for small/nearly sorted data"},
{u:"IV",topic:"Sorting - Exchange",q:"Exchange Sort?",a:"Repeatedly <strong>exchanges/swaps</strong> elements<br><br>â€¢ Bubble sort is an exchange sort<br><br>â€¢ Compares and swaps adjacent pairs"},
{u:"IV",topic:"Sorting - Merge",q:"Merge Sort algorithm?",a:"<strong>Divide & Conquer:</strong><br><br>1. Divide array into two halves<br><br>2. Recursively sort each half<br><br>3. Merge sorted halves"},
{u:"IV",topic:"Sorting - Merge",q:"Merge Sort characteristics?",a:"â€¢ <strong>Stable</strong> sorting<br><br>â€¢ Time: O(n log n) all cases<br><br>â€¢ Space: O(n) - needs auxiliary array<br><br>â€¢ Good for large datasets"},
{u:"IV",topic:"Sorting - Merge",q:"Merge operation?",a:"Compare first elements of two sorted lists<br><br>â€¢ Take smaller element<br><br>â€¢ Repeat until both lists empty"},
{u:"IV",topic:"Sorting - Quick",q:"Quick Sort algorithm?",a:"<strong>Divide & Conquer:</strong><br><br>1. Choose pivot element<br><br>2. Partition: elements < pivot left, > pivot right<br><br>3. Recursively sort partitions"},
{u:"IV",topic:"Sorting - Quick",q:"Quick Sort characteristics?",a:"â€¢ <strong>Unstable</strong> sorting<br><br>â€¢ Best/Avg: O(n log n)<br><br>â€¢ Worst: O(nÂ²) - bad pivot<br><br>â€¢ Space: O(log n)<br><br>â€¢ Fast in practice"},
{u:"IV",topic:"Sorting - Quick",q:"Quick Sort vs Merge Sort?",a:"<strong>Quick:</strong> In-place, faster avg, O(nÂ²) worst<br><br><strong>Merge:</strong> O(n log n) guaranteed, needs extra space<br><br>â€¢ Quick better for arrays, Merge for linked lists"},
{u:"IV",topic:"Searching - Linear",q:"Linear Search algorithm?",a:"1. Start from first element<br><br>2. Compare with target<br><br>3. Move to next if no match<br><br>4. Return index or -1"},
{u:"IV",topic:"Searching - Linear",q:"Linear Search characteristics?",a:"â€¢ Sequential checking<br><br>â€¢ Works on unsorted data<br><br>â€¢ Time: O(n)<br><br>â€¢ Space: O(1)<br><br>â€¢ Simple but slow"},
{u:"IV",topic:"Searching - Binary",q:"Binary Search algorithm?",a:"1. Find middle element<br><br>2. Compare with target<br><br>3. If match, return index<br><br>4. If target < mid, search left half<br><br>5. If target > mid, search right half"},
{u:"IV",topic:"Searching - Binary",q:"Binary Search characteristics?",a:"â€¢ Requires <strong>sorted</strong> array<br><br>â€¢ Divide and conquer<br><br>â€¢ Time: O(log n)<br><br>â€¢ Space: O(1) iterative, O(log n) recursive"},
{u:"IV",topic:"Searching - Binary",q:"Binary Search vs Linear Search?",a:"<strong>Binary:</strong> O(log n), needs sorted data, faster<br><br><strong>Linear:</strong> O(n), works on unsorted, simpler<br><br>â€¢ Binary efficient for large sorted datasets"},
{u:"IV",topic:"Hashing - Basics",q:"What is a Hash Table?",a:"Data structure for <strong>key-value</strong> storage<br><br>â€¢ Uses hash function to compute index<br><br>â€¢ Average O(1) insert/search/delete"},
{u:"IV",topic:"Hashing - Basics",q:"What is a Hash Function?",a:"Maps key to array index<br><br>â€¢ Should distribute keys uniformly<br><br>â€¢ Example: h(k) = k % table_size"},
{u:"IV",topic:"Hashing - Basics",q:"Common Hash Functions?",a:"â€¢ <strong>Division:</strong> h(k) = k mod m<br><br>â€¢ <strong>Multiplication:</strong> h(k) = âŒŠm(kA mod 1)âŒ‹<br><br>â€¢ <strong>Mid-square:</strong> square key, extract middle digits<br><br>â€¢ <strong>Folding:</strong> divide key into parts, add"},
{u:"IV",topic:"Hashing - Collision",q:"What is a Collision?",a:"Two keys map to <strong>same index</strong><br><br>â€¢ Inevitable with limited table size<br><br>â€¢ Resolved using collision resolution techniques"},
{u:"IV",topic:"Hashing - Collision",q:"Collision Resolution methods?",a:"<strong>Open Hashing:</strong> Chaining<br><br><strong>Closed Hashing:</strong> Open addressing<br><br>â€¢ Linear probing<br><br>â€¢ Quadratic probing<br><br>â€¢ Double hashing"},
{u:"IV",topic:"Hashing - Chaining",q:"Chaining (Separate Chaining)?",a:"Each table slot has <strong>linked list</strong><br><br>â€¢ Colliding elements stored in list<br><br>â€¢ Simple, handles any load factor<br><br>â€¢ Extra memory for pointers"},
{u:"IV",topic:"Hashing - Chaining",q:"Chaining operations?",a:"<strong>Insert:</strong> Add to list at index<br><br><strong>Search:</strong> Traverse list at index<br><br><strong>Delete:</strong> Remove from list<br><br>â€¢ Time: O(1 + Î±) where Î± = n/m"},
{u:"IV",topic:"Hashing - Probing",q:"Linear Probing?",a:"Probe sequence: h(k), h(k)+1, h(k)+2, ...<br><br>â€¢ Check next slot if occupied<br><br>â€¢ <strong>Primary clustering</strong> problem<br><br>â€¢ Good cache performance"},
{u:"IV",topic:"Hashing - Probing",q:"Quadratic Probing?",a:"Probe sequence: h(k), h(k)+1Â², h(k)+2Â², ...<br><br>â€¢ Reduces primary clustering<br><br>â€¢ <strong>Secondary clustering</strong> can occur<br><br>â€¢ Better distribution"},
{u:"IV",topic:"Hashing - Probing",q:"Double Hashing?",a:"Use two hash functions h1 and h2<br><br>â€¢ Probe: h1(k), h1(k)+h2(k), h1(k)+2h2(k), ...<br><br>â€¢ No clustering<br><br>â€¢ Best distribution"},
{u:"IV",topic:"Hashing - Probing",q:"Open Addressing vs Chaining?",a:"<strong>Open Addressing:</strong><br><br>â€¢ All data in table, no pointers<br><br>â€¢ Better cache, worse with high load<br><br><strong>Chaining:</strong><br><br>â€¢ Linked lists, extra memory<br><br>â€¢ Handles overflow gracefully"},
{u:"IV",topic:"Hashing - Load Factor",q:"Load Factor Î±?",a:"Î± = n / m<br><br>â€¢ n = number of keys<br><br>â€¢ m = table size<br><br>â€¢ Affects performance<br><br>â€¢ Keep < 0.7 for open addressing"},
{u:"II",topic:"Stack",q:"Stack follows {{c1::LIFO}} principle with operations at {{c1::one end}}."},
{u:"II",topic:"Queue",q:"Queue follows {{c1::FIFO}} principle with insert at {{c1::REAR}} and delete at {{c1::FRONT}}."},
{u:"III",topic:"Trees - Binary",q:"Max nodes in complete binary tree of height h = {{c1::2^(h+1)-1}}."},
{u:"III",topic:"Trees - BST",q:"In BST, {{c1::left subtree}} < root < {{c1::right subtree}}."},
{u:"III",topic:"Trees - Traversal",q:"Inorder traversal: {{c1::Left}}-{{c1::Root}}-{{c1::Right}}."},
{u:"III",topic:"Graph - Representation",q:"Adjacency matrix space: {{c1::O(VÂ²)}}. Adjacency list space: {{c1::O(V+E)}}."},
{u:"II",topic:"Queue",q:"In circular queue, REAR = {{c1::(REAR+1)%MAX}}."},
{u:"III",topic:"Trees - Binary",q:"Minimum height of binary tree with n nodes = {{c1::logâ‚‚(n+1)}}."},
{u:"IV",topic:"Sorting - Quick",q:"In Quick Sort, partitioning places {{c1::smaller elements left}}, pivot in {{c1::correct position}}, {{c1::larger elements right}}."},
{u:"IV",topic:"Sorting - Merge",q:"Merge Sort time complexity: {{c1::O(n log n)}} in all cases."},
{u:"IV",topic:"Searching - Binary",q:"Binary Search time complexity: {{c1::O(log n)}}. Requires {{c1::sorted}} array."},
{u:"IV",topic:"Hashing - Basics",q:"Average hash table operations: {{c1::O(1)}} for insert, search, delete."},
{u:"IV",topic:"Hashing - Collision",q:"Two collision resolution categories: {{c1::Open Hashing (Chaining)}} and {{c1::Closed Hashing (Open Addressing)}}."},
];

const units = [...new Set(data.map(d=>d.u))];
const topics = [...new Set(data.map(d=>d.topic))];
let unitFilter = 'All';
let topicFilter = 'All';

function init(){
  const uf = document.getElementById('unitFilter');
  uf.innerHTML = '<label>Unit:</label><button class="active" onclick="setUnitFilter(\'All\')">All</button>';
  units.forEach(u=>{
    uf.innerHTML += `<button onclick="setUnitFilter('${u}')">Unit ${u}</button>`;
  });
  
  const tf = document.getElementById('topicFilter');
  tf.innerHTML = '<label>Topic:</label><button class="active" onclick="setTopicFilter(\'All\')">All</button>';
  
  render();
}

function setUnitFilter(u){
  unitFilter = u;
  document.querySelectorAll('#unitFilter button').forEach(b=>{
    b.classList.toggle('active', (u==='All' && b.textContent==='All') || b.textContent==='Unit '+u);
  });
  updateTopicFilter();
  render();
}

function updateTopicFilter(){
  const tf = document.getElementById('topicFilter');
  const filteredTopics = unitFilter === 'All' 
    ? topics 
    : [...new Set(data.filter(d=>d.u===unitFilter).map(d=>d.topic))];
  
  tf.innerHTML = '<label>Topic:</label><button class="active" onclick="setTopicFilter(\'All\')">All</button>';
  filteredTopics.forEach(t=>{
    tf.innerHTML += `<button onclick="setTopicFilter('${t.replace(/'/g,"\\'")}')">${t}</button>`;
  });
  topicFilter = 'All';
}

function setTopicFilter(t){
  topicFilter = t;
  document.querySelectorAll('#topicFilter button').forEach(b=>{
    b.classList.toggle('active', b.textContent===t);
  });
  render();
}

function render(){
  const c = document.getElementById('cards');
  c.innerHTML = '';
  data.forEach((d,i)=>{
    const unitMatch = unitFilter==='All' || d.u===unitFilter;
    const topicMatch = topicFilter==='All' || d.topic===topicFilter;
    const show = unitMatch && topicMatch;
    const isCloze = d.q.includes('{{c1::');
    
    let html = `<div class="card ${show?'':'hidden'}">
      <div class="unit">Unit ${d.u}</div>
      <div class="topic">${d.topic}</div>
      <div class="q">${isCloze ? d.q.replace(/\{\{c1::(.*?)\}\}/g,'<span class="cloze">$1</span>') : d.q}</div>`;
    
    if(!isCloze){
      html += `<div class="a" id="a${i}">${d.a||''}</div>
        <div class="btns">
          <button onclick="toggle(${i})">Reveal</button>
          <button onclick="copy(\`${d.q}\`,\`${d.a||''}\`)">Copy</button>
        </div>`;
    } else {
      html += `<div class="btns">
        <button onclick="revealCloze(${i})">Reveal</button>
        <button onclick="copyCloze(\`${d.q}\`)">Copy</button>
      </div>`;
    }
    html += '</div>';
    c.innerHTML += html;
  });
}

function toggle(i){
  document.getElementById('a'+i).classList.toggle('show');
}

function revealCloze(i){
  document.querySelectorAll('.card')[i].querySelectorAll('.cloze').forEach(el=>{
    el.classList.add('revealed');
  });
}

function copy(q,a){
  const clean = s => s.replace(/<br>/g,' ').replace(/<[^>]*>/g,'');
  navigator.clipboard.writeText(`${clean(q)}\t${clean(a)}`);
}

function copyCloze(q){
  navigator.clipboard.writeText(q);
}

init();
</script>
</body>
</html>
